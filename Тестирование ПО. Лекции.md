Дополнительные материалы:
-   Бындью Александр "Модульные отладки на примере разработки отчетов".
-   IOC-контейнер.
-   Попов TDD
-   Вигерс "Разработка требований к ПО"

# Лекция 2

## Основные критерии тестирования (класс 1)
1.  *Условие критерия тестирования команд (критерий C0)*. Набор тестов в совокупности должен обеспечить прохождение каждой команды не менее одного раза. Это слабый критерий используется в больших программных системах, где другие критерии применить не возможно.
2.  *Условия критерия тестирования ветвей (критерий С1)*. Набор тестов в совокупности должен обеспечить прохождение каждого критерия не менее одного раза. Но применяется при тестировании ветвей. Это достаточно экономичный критерий, поскольку множество ветвей в тестируемом приложении конечно и не так велико. Используется в системах автоматизации систем.
3.  *Условие критерия тестирования путей (критерий C2)*. Набор тестов в совокупности должен обеспечить прохождения одного пути не менее одного раза. Если программа содержит цикл, в особенности с неявно заданным числом итераций, то число итераций ограничивается константой.

```
public void Method(ref int x)
{
    if (x > 17)
        x = 17-x;
    if (x >= -13)
        x = 0;
}
```

Тестовый набор удовлетворяет критерию команд на таком наборе:

>    (X, Y) = { (x_in = 30, x_out = 0) }

Покрывает все операторы трассы 1 - 2 - 3 - 4 - 5 -6

Тестовый набор из двух тестов

>    (X, Y) = { (30, 0), (17, 17) }

Удовлетворяет критерию ветвей C1 и добавляет к множеству C0 и трассу 1 - 2 - 4 - 6. Трасса 1 - 2 - 3 - 4 - 5 - 6 проходит через все ветви, достижимые в операторах if при условии true. А трасса 1 - 2 - 4 - 6 через все ветви, достижимые в операторах if при условии false.

Тестовый набор из четырех тестов удовлетворяет критерию C2.

>   (X, Y) = { (30, 0), (17, 17); (13, 0), (21, -4) }

Критерий C2 программу более тщательно, чем критерий C1. Однако даже в случае, если он удовлетворен нет оснований утверждать, что программа реализована в соответствии со спецификацией. Например, если спецификация задает условие, что

> |x| <= 100

то невыполнимость такого условия можно подтвердить на значении -177. Операторы 3 и 4 не изменят величину и результат не будет соответствовать спецификации.

|              |(30, 0) | (17, 1) | (-13, 0) | (21, -4) |
|--------------|--------|---------|----------|----------|
|if (x>17)     | >      | <       | <        | >        |
|if (x == -13) | =      | !=      | =        | !=       |

Структурные критерии не проверяют в соответствии со спецификацией, если оно не отражено в структуре программы, поэтому при успешном тестировании программы по критерию C2 можно не заметить ошибку, связанную с невыполнением условием требования спецификации.

*Функциональный критерий*. Обеспечивает контроль степени выполнения требования заказчика, в программном продукте. Посколько требование формируется к продукту в целом функциональные критерии используют, в основном, модель черного ящика. Проблема функционального тестирования - трудоемкость. Это связанно с *software requirment specification* и *functional specification*.

### Основыне виды функциоанльных критериев (класс 2)

-   *Тестирование пунктов спецификации*. Это означает, что набор тестов в совокупности должен обеспечить каждого тестируемого пункта не менее одного раза.
-   *Тестирование спецификации требований* - каждый пункт должен быть проверен в соответствии с критерием не менее чем одним тестом
-   *Тестирование классов входных данных* - набор тестов в совокупности должен обеспечить проверку представителя каждого класса входных данных не менее одного раза. При создании тестов классы входных данных сопоставляются с режимами использования тестируемого компонента для сокращения тестовых наборов.
-   *Тестирование правил* - набор тестов в совокупности должен обеспечить проверку каждого правила, если входные и выходные значения описываются набором правил некоторой грамматики. При этом грамматика должна быть достаточно простой, чтобы трудоемкость разработки набора тестов была реальной.
-   *Тестирование классов выходных данных* - набор тестов в совокупности должен обеспечить проверку представителя каждого выходного класса, при условии классификации выходных результатов заранее. При создании тестов выходных данных классы составляются с использованием тестируемого компонента или системы, что заметно сокращает варианты перебора при разработки тестовых наборов.
-   *Тестирование функций* - набор тестов в совокупности должен обеспечить проверку каждого действия, реализуемого тестируемым модулем не менее одного раза. Критерий тестирования функции отчасти объединяет особенности стрктурных и функциональных критериев. Базируется на модели полупрозрачного ящика, где явно указаны входы и выходы тестируемого компонента, но так же состав и структура, используемых методов и классов.
-   *Комбинированные критерии для программ и спецификаций* - набор тестов в совокупности должен обеспечить проверку всех комбинаций непротиворечивых условий программы и спецификаций не менее одного раза.

### Стохастические критерии (класс 3)

Стохастическое тестирование применяется при тестировании сложных программных комплексов, когда набор входных / выходных тестов имеет большую мощность.

Критерии стохастического тестирования:
-   *Статистические методы окончания тестирования* дают возможность определить решение о совпадении гипотез о распределении случайных величин (метод Стъюдента, хи-квадрат).
-   *Метод оценки скорости выявления ошибок*. Основан на модели, согласно которой тестирование прекращается, если оценненый интервал времени между текущей ошибкой и следующей слишком велик для фазы тестирования приложений.


### ААА в действии
```
var reporter = new Reporter();          // Arrange
int CountReport = report.SendReports(); // Act
Assert.AreEqual(2, CountReport);        // Assert
```

_Фрейморвки для тестирования:_ XUnit, NUnit


# Лекция 3. Оценка тестированности проекта: метрики и методика интегральной оценки

### Оценка покрытия программы и проекта

Тестирование программы _P_ по некоторому критерию _C_ означает покрытие множества компонентов программы _P_, представляющих из себя множество модулей
> M = {m_1, ..., m_k}

по элементам или связям. При этом
> T = {t_1, ..., t_n}_ - кортеж неизбыточных тестов

Тест _t_j_ не избыточен, если существует покрытый им компонент _m_i_ из пар программы и критерия: _M(P, C)_ непокрытый ни одним из предыдущих тестов *t_1, ..., t_(j-1)* каждому _t_j_ соответсвует неизбыточный путь _p_i_, при этом _p_i_ - последовательность вершин от выхода или входа программ. Здесь _j = 1..n_

_V(P, C)_ - сложность тестирования _P_ по критерию  _C_. Измеряется максимальным числом неизбыточных тестов, покрывающих все элементы множества _M(P, C)_

_DV(P, C)_ - остаточная сложность тестирования _P_ по критерию _C_. Измеряется максимальным числом неизбыточных тестов, покрывающих элементы множества _M(P, C)_, оставшиеся непокрытыми после прогона набора тестов _T_. Величина _DV_ строго и монотонно убывает от _V_ до 0.

_TV(P, C, T) = (V - DV) / V_ - оценка степени тестрованния _P_ по критерию _C_.

Критерий окончания тестирования: _TV(P, C, T) ≥ L; (0 ≤ L ≤ 1)_ задан в требованиях к программноому продукту

### Методика интегральной оценки тестрованности

Включает в себя 8 шагов:
1.  Выбор критерия _C_ и приемочные оценки тестрованности программного проекта _L_
2.  Построение дерева классов проекта и построение графа управления для каждого модуля
3.  Модульное тестирование и оценка степени тестрованности _TV_ на модульном уровне
4.  Построение графо-управления, интегрирующего модули в единую иерарахическую модель проекта.
5.  Выбор тестовых путей для проведения инетграционного или системного тестирования.
6.  Генерация тестов, покрывающих тестовые пути на 5 шаге.
7.  Интегральная оценка тестированности проекта с учетом оценки тестированности модулей компонент.
8.  Повторение шага 5-7 до достижения заданного уровня тестированности _L_

# Лекция 4.
IoC (Invertional control) - штука для вынесения создание самих объектов на самый верх (в итоге через конфиг файл)

# Лекция 5. Верификация тестирования и оценивание корректности программных компонентов

__Верификация__ — процесс определения выполнения требований программными средствами и компонентами на этапах жизненного цикла программного средства. Основная цель верификации состоит в том, чтобы обнаружить, зарегистрировать и устранить дефекты и ошибки, которые внесены во время пользовательской разработке или модификации программы. Для эффективности использования ресурсов при ее реализации, верификация должна быть интегрирована как можно раньше с процессами проектирования разработки и сопровождения. Обычно она проводится сверху вниз, начиная от общих требований, заданных в техническом задании и / или спецификации на всю информационную систему до детальных требований на программные модули и их взаимодействие.

Назначение верификации — последовательно проверить, что:
1.	Общие требования к информационной системе, предназначенные для программной реализации, корректно переработаны в спецификацию требований высокого уровня комплекса программ, удовлетворяющим исходным системным требованиям.
2.	Требования высокого уровня, правильно переработано в архитектуру программного средства и в спецификации требований функциональных компонентов низкого уровня.
3.	Спецификация требований к функциональным требованиям компонентов ПС, расположены между высоким и низким уровнем, должны каждый раз удовлетворять требованиям более высокого уровня.
4.	Архитектура программных средств и спецификация требований компонент низкого уровня должны быть корректно переработанных в удовлетворяющие им исходные тексты программ и информационных формулы.
5.	Исполняемый объектный код удовлетворяет требованиям к исходным текстам программных компонентов.

Цели верификации достигаются посредство последовательного выполнения комбинаций из просмотров, анализов, разработки тестовых сценариев и последующего выполнения тестовых процедур. Тестовые сценарии предназначены для проверки внутренней непротиворечивости и полноты. Выполнение тестовых процедур должно обеспечивать демонстрацию соответствия испытываемых программ исходным требованиям.

Результаты верификации должны быть включены следующие документы:
-	Выполненные процедуры верификации
-	Описание отчет о квалификационном тестировании программного средства и его компоненты

Просмотры и анализы требований высокого уровня предназначены для обнаружения регистрации, устранения дефектов и ошибок, которые внесены в процессе последовательной разработки и детализации спецификации требований к программным средствам. Эти просмотры и анализы должны подтвердить корректность и согласованность требований высокого уровня, а так же гарантировать, что:
1.	Полностью определены функции информационной системы, которые должно выполнять программное средство
2.	Требования по функциональности, эффективности и качеству системы детализированы в исходных требованиях высокого уровня и что правильно определены производные требования и обоснована их необходимость.
3.	Каждое требование высокого уровня программного средства является точным, однозначным и достаточно детализированным, при этом требования не конфликтуют друг с другом.
4.	Не существует никаких конфликтов между требованиями высокого уровня и возможностями аппаратных и программных средств, особенно такими, как время реакции системы и характеристики аппаратуры ввода-вывода.
5.	Процесс разработки требований к программному средству полностью соответствует стандартам на создание спецификации требований и любые отклонения от стандартов обоснованы.
6.	Функциональные и конструктивные характеристики качества, предназначенные для программной реализации полностью включены в требования высокого уровня программного средства.

### Тестирования программных средств по требованиями

Имеет 2 цели:
1.	Показать, что программное средства удовлетворяет заданным требованиям к нему.
2.	Показать с высокой степенью доверия, что устранены дефекты и ошибки, которые могли бы привести к возникновению недопустимых отказов и ситуаций, влияющих на корректность и работу системы.

Анализ покрытия тестами требований к программному средству должен определять какие требования не были протестированы и какие структуры программного средства не были тестированы.

Включает в себя 2 шага:
1.	Анализ тестовых наборов. Относительно требования программного средства, чтобы подтвердить, что выбранные наборы тестов удовлетворяют установленным критериям.
2.	Должен подтвердить, что процедуры тестирования, основанные на требованиях, покрыли всю структуру программы, анализ структурного покрытия должен определять, не пропущен ли элементы структуры программы, которые не проверены тестовыми процедурами, основанными на требованиях.

### Взаимосвязь разработки и тестирования (V-диаграмма)
![Alt text](scheme1.png)

### Методы обеспечения качества относительно простых программ
1.	Тестирование для обнаружения ошибок. Имеет целью выявление отклонений результата функционирования реальной программы от заданных требований и эталонных значений. Успешным является тестирование, позволяющее обнаружить ошибку при минимальных затратах.
2.	Тестирование для диагностики и локализации ошибок. Предназначено для того, чтобы точно установить исходное место искажения программ или данных. Тестирование можно считать успешным, если определены элементы программы или данные, подлежащие корректировки.

Тестирование программных модулей включает в себя:
1.	Тестирование потоков управления (струкутры программы). Должно быть начальным этапом, чтобы избежать искажения выходных результатов при некорректной структуре программы. Состоит в проверке корректности последовательности передач управления и формирования маршрутов исполнения программы при обработке тестов. Требуется относительно меньшие затраты по сравнению с тестированием на потоках данных.
2.	Тестирование потока данных. Можно разделить на 2 этапа:
    1.	Анализ обработки данных, определяющих значение предиката в операторах выработки логических решений.
    2.	Проверка вычислений по аналитическим формулам или численных значений результатов, в зависимости от числовых или логических значений исходных данных. В качестве эталонов используются результаты ручных или автоматизированных расчетов по тем же или близких по содержанию формулам.

Совокупность спецификации тестов можно рассматривать, как независимое описание содержания и реализации последовательных процедур комплексов программы.
